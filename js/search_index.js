var search_data = {"index":{"searchIndex":["fixnum","hash","log2counter","parser","date","printer","version","logformat","logparser","formaterror","string","<=>()","<=>()","_log2counter_original_cmp()","_log2counter_original_cmp()","check_format()","generate_stats()","get_page()","initialize_known_formats()","initialize_licensees()","load()","load()","new()","new()","new()","new()","parse()","parse()","parse_format()","parse_io_stream()","parse_line()","print()","print()","process_directive()","sort_by_ip_or_host()","to_a()","to_s()","copying","changelog","readme"],"longSearchIndex":["fixnum","hash","log2counter","log2counter::parser","log2counter::parser::date","log2counter::printer","log2counter::version","logformat","logparser","logparser::formaterror","string","fixnum#<=>()","string#<=>()","fixnum#_log2counter_original_cmp()","string#_log2counter_original_cmp()","logparser#check_format()","logparser#generate_stats()","logparser#get_page()","logparser#initialize_known_formats()","log2counter::parser#initialize_licensees()","log2counter#load()","log2counter::parser::load()","log2counter::parser::new()","log2counter::printer::new()","logformat::new()","logparser::new()","log2counter#parse()","log2counter::parser#parse()","logformat#parse_format()","logparser#parse_io_stream()","logparser#parse_line()","log2counter#print()","log2counter::printer#print()","logformat#process_directive()","hash#sort_by_ip_or_host()","log2counter::version::to_a()","log2counter::version::to_s()","","",""],"info":[["Fixnum","","Fixnum.html","",""],["Hash","","Hash.html","",""],["Log2COUNTER","","Log2COUNTER.html","",""],["Log2COUNTER::Parser","","Log2COUNTER/Parser.html","",""],["Log2COUNTER::Parser::Date","","Log2COUNTER/Parser/Date.html","",""],["Log2COUNTER::Printer","","Log2COUNTER/Printer.html","",""],["Log2COUNTER::Version","","Log2COUNTER/Version.html","",""],["LogFormat","","LogFormat.html","",""],["LogParser","","LogParser.html","",""],["LogParser::FormatError","","LogParser/FormatError.html","",""],["String","","String.html","","<p>Allow to compare strings and fixnums; the latter sorting before the other.\n"],["<=>","Fixnum","Fixnum.html#method-i-3C-3D-3E","(other)",""],["<=>","String","String.html#method-i-3C-3D-3E","(other)",""],["_log2counter_original_cmp","Fixnum","Fixnum.html#method-i-_log2counter_original_cmp","(other)",""],["_log2counter_original_cmp","String","String.html#method-i-_log2counter_original_cmp","(other)",""],["check_format","LogParser","LogParser.html#method-i-check_format","(line)","<p>Checks which standard the log file (well one line) is. Automatically checks\nfor most complex (longest) …\n"],["generate_stats","LogParser","LogParser.html#method-i-generate_stats","(parsed_data)","<p>Populate a stats hash one line at a time. Add extra fields into the\nSTAT_ENV_MAP hash at the top of this …\n"],["get_page","LogParser","LogParser.html#method-i-get_page","(request)",""],["initialize_known_formats","LogParser","LogParser.html#method-i-initialize_known_formats","()","<p>Processes the format string into symbols and test regex and saves using\nLogFormat class.\n"],["initialize_licensees","Log2COUNTER::Parser","Log2COUNTER/Parser.html#method-i-initialize_licensees","()","<p>Create additional mappings for our licensees.\n"],["load","Log2COUNTER","Log2COUNTER.html#method-i-load","(*args)",""],["load","Log2COUNTER::Parser","Log2COUNTER/Parser.html#method-c-load","(csv_file)",""],["new","Log2COUNTER::Parser","Log2COUNTER/Parser.html#method-c-new","(log_file, licensees, months = nil, regexp = nil)",""],["new","Log2COUNTER::Printer","Log2COUNTER/Printer.html#method-c-new","(csv_file, summarize = false)",""],["new","LogFormat","LogFormat.html#method-c-new","(name, format)",""],["new","LogParser","LogParser.html#method-c-new","(format = nil, constraint = nil)",""],["parse","Log2COUNTER","Log2COUNTER.html#method-i-parse","(*args)",""],["parse","Log2COUNTER::Parser","Log2COUNTER/Parser.html#method-i-parse","()","<p>Now here&#39;s the method you want to call. Returns a hash:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">stats</span> = {\n  <span class=\"ruby-string\">&#39;2007_06&#39;</span> =<span class=\"ruby-operator\">&gt;</span> {\n    <span class=\"ruby-string\">&#39;Somewhere, ...\n</span></pre>\n"],["parse_format","LogFormat","LogFormat.html#method-i-parse_format","(format)","<p>The symbols are used to map the log to the env variables. The regex is used\nwhen checking what format …\n"],["parse_io_stream","LogParser","LogParser.html#method-i-parse_io_stream","(stream)","<p>This is where the magic happens. This is the end-to-end business logic of\nthe class.\n<p>Call with a block …\n"],["parse_line","LogParser","LogParser.html#method-i-parse_line","(line)",""],["print","Log2COUNTER","Log2COUNTER.html#method-i-print","(stats, *args)",""],["print","Log2COUNTER::Printer","Log2COUNTER/Printer.html#method-i-print","(stats)",""],["process_directive","LogFormat","LogFormat.html#method-i-process_directive","(directive_char, subdirective, condition)",""],["sort_by_ip_or_host","Hash","Hash.html#method-i-sort_by_ip_or_host","()","<p>Sort IP addresses numerically by net part, and host names just as usual.\n"],["to_a","Log2COUNTER::Version","Log2COUNTER/Version.html#method-c-to_a","()","<p>Returns array representation.\n"],["to_s","Log2COUNTER::Version","Log2COUNTER/Version.html#method-c-to_s","()","<p>Short-cut for version string.\n"],["COPYING","","COPYING.html","","<p>License for log2counter\n\n<pre>                    GNU AFFERO GENERAL PUBLIC LICENSE\n                       Version ...</pre>\n"],["ChangeLog","","ChangeLog.html","","<p>Revision history for log2counter\n<p>0.0.1 [2009-07-22]\n<p>Birthday :-)\n"],["README","","README.html","","<p>log2counter - Convert (analyse) Apache log files to COUNTER CSV.\n<p>VERSION\n<p>This documentation refers to log2counter …\n"]]}}